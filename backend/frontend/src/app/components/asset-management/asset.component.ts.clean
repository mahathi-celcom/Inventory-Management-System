import { 
  Component, 
  OnInit, 
  OnDestroy, 
  ChangeDetectionStrategy, 
  ChangeDetectorRef,
  ViewChild,
  TemplateRef,
  inject,
  signal,
  computed
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormsModule } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginatorModule, PageEvent } from '@angular/material/paginator';
import { MatTableModule } from '@angular/material/table';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatMenuModule } from '@angular/material/menu';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatCardModule } from '@angular/material/card';
import { MatDividerModule } from '@angular/material/divider';
import { CdkVirtualScrollViewport, ScrollingModule } from '@angular/cdk/scrolling';
import { SelectionModel } from '@angular/cdk/collections';
import { LayoutComponent, NavigationItem } from '../shared/layout/layout.component';

import { 
  Subject, 
  takeUntil, 
  debounceTime, 
  distinctUntilChanged, 
  combineLatest,
  startWith,
  switchMap,
  catchError,
  of,
  BehaviorSubject,
  finalize
} from 'rxjs';

import { AssetService } from '../../services/asset.service';
import { AssignmentService } from '../../services/assignment.service';
import { ConfigurationService, StatusOption, OwnerTypeOption, AcquisitionTypeOption, AssetConfigSettings, DefaultValues } from '../../services/configuration.service';
import { StatusHistoryModalComponent } from './status-history-modal/status-history-modal.component';
import { 
  Asset, 
  AssetFilter, 
  AssetFilterOptions,
  PageResponse,
  AssetType,
  AssetMake,
  AssetModel,
  AssetModelWithDetails,
  AssetModelDetails,
  VendorWarrantyDetails,
  PODetails,
  Vendor,
  User,
  OperatingSystem,
  OSVersion,
  PurchaseOrder,
  AssetPODTO,
  AssetStatusHistory,
  AssetStatusHistoryDTO,
  AssetStatusChangeRequest,
  AssetStatusChangeResponse,
  ASSET_STATUS,
  ASSET_STATUS_DISPLAY,
  ASSET_STATUS_FILTER,
  ASSET_STATUS_FILTER_DISPLAY,
  OWNER_TYPE,
  ACQUISITION_TYPE,
  ASSET_MESSAGES,
  ASSET_CONFIG,
  AssetUserAssignment,
  AssetUserAssignmentRequest,
  AssetUserAssignmentDTO,
  AssetTag,
  AssetTagAssignment,
  AssetTagAssignmentRequest,
  AssetTagAssignmentDTO,
  AssetTagAssignmentByNameDTO,
  ActiveUser
} from '../../models/asset.model';
import { AssetPO } from '../../models/asset-po.model';

@Component({
  selector: 'app-asset',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    MatTableModule,
    MatPaginatorModule,
    MatProgressSpinnerModule,
    MatButtonModule,
    MatIconModule,
    MatInputModule,
    MatSelectModule,
    MatCheckboxModule,
    MatChipsModule,
    MatTooltipModule,
    MatMenuModule,
    MatFormFieldModule,
    MatCardModule,
    MatDividerModule,
    ScrollingModule,
    StatusHistoryModalComponent,
    LayoutComponent
  ],
  templateUrl: './asset.component.html',
  styleUrl: './asset.component.css',
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class AssetComponent implements OnInit, OnDestroy {
  @ViewChild('assetFormModal') assetFormModal!: TemplateRef<any>;
  @ViewChild(CdkVirtualScrollViewport) virtualScrollViewport!: CdkVirtualScrollViewport;

  // Navigation
  navigationItems: NavigationItem[] = [];

  // Signals for reactive state management
  loading = signal(false);
  assets = signal<Asset[]>([]);
  totalAssets = signal(0);
  currentPage = signal(0);
  pageSize = signal(ASSET_CONFIG.PAGE_SIZE);
  isFormModalOpen = signal(false);
  selectedAsset = signal<Asset | null>(null);
  isEditMode = signal(false);

  // ✅ NEW: Status change functionality signals
  statusChangeLoading = signal(false);
  statusHistoryLoading = signal(false);
  statusHistory = signal<AssetStatusHistory[]>([]);
  statusChangeError = signal<string | null>(null);
  showStatusHistory = signal(false);
  showStatusChangeModal = signal(false);
  selectedAssetForStatusChange = signal<Asset | null>(null);
  pendingStatusChange = signal<string>('');

  // ✅ NEW: Status History Modal state
  showStatusHistoryModal = signal(false);
  statusHistoryModalAsset = signal<{ id: number; name: string; serial: string } | null>(null);

  // ✅ NEW: User Assignment state
  showUserAssignmentModal = signal(false);
  selectedAssetForUserAssignment = signal<Asset | null>(null);
  currentUserAssignment = signal<AssetUserAssignment | null>(null);
  activeUsers = signal<ActiveUser[]>([]);
  userAssignmentLoading = signal(false);
  userAssignmentError = signal<string | null>(null);
  userAssignmentForm!: FormGroup;

  // ✅ NEW: Tag Assignment state
  showTagAssignmentModal = signal(false);
  selectedAssetForTagAssignment = signal<Asset | null>(null);
  availableTags = signal<AssetTag[]>([]);
  assignedTags = signal<AssetTagAssignment[]>([]);
  tagAssignmentLoading = signal(false);
  tagAssignmentError = signal<string | null>(null);
  selectedTagsForAssignment = signal<number[]>([]);

  // ✅ NEW: Inline "Add Tag" state
  showAddTagInline = signal(false);
  newTagName = signal<string>('');
  addTagLoading = signal(false);
  addTagError = signal<string | null>(null);

  // ✅ NEW: UI state for collapsible sections
  editableSections = signal<Map<number, boolean>>(new Map());
  poSections = signal<Map<number, boolean>>(new Map());

  // ✅ NEW: Assignment History Modal
  showAssignmentHistoryModal = signal(false);
  selectedAssetForAssignmentHistory = signal<Asset | null>(null);
  assignmentHistory = signal<AssetUserAssignment[]>([]);
  assignmentHistoryLoading = signal(false);

  // ✅ NEW: PO Details Modal
  showPODetailsModal = signal(false);
  selectedPOForDetails = signal<string>('');
  selectedPODetails = signal<PODetails | null>(null);

  // Computed properties
  filteredAssets = computed(() => {
    const assetList = this.assets();
    const filters = this.currentFilters();
    
    if (!filters.search && !filters.status && !filters.ownership && !filters.model && !filters.osVersion && !filters.assignmentStatus) {
      return assetList;
    }

    return assetList.filter(asset => {
      const matchesSearch = !filters.search || 
        asset.name.toLowerCase().includes(filters.search.toLowerCase()) ||
        asset.serialNumber?.toLowerCase().includes(filters.search.toLowerCase()) ||
        asset.itAssetCode?.toLowerCase().includes(filters.search.toLowerCase());

      const matchesStatus = !filters.status || filters.status === 'All' || asset.status === filters.status;
      const matchesOwnership = !filters.ownership || filters.ownership === 'All' || asset.ownerType === filters.ownership;
      const matchesModel = !filters.model || asset.modelId?.toString() === filters.model;
      const matchesOSVersion = !filters.osVersion || asset.osVersionId?.toString() === filters.osVersion;
      
      const matchesAssignment = !filters.assignmentStatus || 
        (filters.assignmentStatus === 'assigned' && asset.currentUserId) ||
        (filters.assignmentStatus === 'unassigned' && !asset.currentUserId);

      return matchesSearch && matchesStatus && matchesOwnership && matchesModel && matchesOSVersion && matchesAssignment;
    });
  });

  // ✅ NEW: Computed properties for filters
  models = computed(() => {
    return this.assetModelsWithDetails().map(model => ({
      id: model.id,
      name: model.name
    }));
  });

  // ✅ NEW: Status dropdown options with proper API/Display mapping
  statusDropdownOptions = computed(() => {
    return Object.entries(ASSET_STATUS).map(([key, apiValue]) => ({
      code: apiValue, // API-safe value (IN_STOCK, ACTIVE, etc.)
      name: ASSET_STATUS_DISPLAY[key as keyof typeof ASSET_STATUS_DISPLAY] // Display name (In Stock, Active, etc.)
    }));
  });

  // ✅ NEW: Status filter options with proper API/Display mapping  
  statusFilterDropdownOptions = computed(() => {
    return Object.entries(ASSET_STATUS_FILTER).map(([key, apiValue]) => ({
      code: apiValue, // API-safe value (IN_STOCK, ACTIVE, etc.)
      name: ASSET_STATUS_FILTER_DISPLAY[key as keyof typeof ASSET_STATUS_FILTER_DISPLAY] // Display name (In Stock, Active, etc.)
    }));
  });

  hasSelectedAssets = computed(() => this.selection.selected.length > 0);
  selectedCount = computed(() => this.selection.selected.length);

  // Form and UI state
  assetForm!: FormGroup;
  filterForm!: FormGroup;
  currentFilters = signal<AssetFilterOptions>({});
  
  // Selection management
  selection = new SelectionModel<Asset>(true, []);
  
  // Dropdown data
  assetTypes = signal<AssetType[]>([]);
  assetModelsWithDetails = signal<AssetModelWithDetails[]>([]);
  vendors = signal<Vendor[]>([]);
  users = signal<User[]>([]);
  operatingSystems = signal<OperatingSystem[]>([]);
  osVersions = signal<OSVersion[]>([]);
  filteredOSVersions = signal<OSVersion[]>([]);
  purchaseOrders = signal<PurchaseOrder[]>([]);
  
  // Read-only fields that get auto-populated
  selectedAssetType = signal<string>('');
  selectedAssetMake = signal<string>('');
  
  // Auto-populated fields from PO selection
  selectedVendor = signal<string>('');
  selectedExtendedWarrantyVendor = signal<string>('');
  
  // Auto-populated fields from OS Version selection
  selectedOSName = signal<string>('');
  
  // Loading states for dependent dropdowns
  osVersionsLoading = signal(false);
  modelDetailsLoading = signal(false);
  poDetailsLoading = signal(false);
  vendorWarrantyLoading = signal(false);
  operatingSystemsLoading = signal(false);
  
  // Error states for dependent fields
  osVersionsError = signal<string | null>(null);
  modelDetailsError = signal<string | null>(null);
  poDetailsError = signal<string | null>(null);
  vendorWarrantyError = signal<string | null>(null);
  
  // Loading error for dropdown data
  operatingSystemsError = signal<string | null>(null);
  
  // ✅ NEW: Specific PO error message as requested
  poErrorMessage = signal<string | null>(null);
  
  // Filtered OS Versions for current OS selection
  currentOSVersions = signal<OSVersion[]>([]);
  
  // Dynamic configuration data
  statusOptions = signal<StatusOption[]>([]);
  statusFilterOptions = signal<StatusOption[]>([]);
  ownerTypeOptions = signal<OwnerTypeOption[]>([]);
  ownerTypeFilterOptions = signal<OwnerTypeOption[]>([]);
  acquisitionTypeOptions = signal<AcquisitionTypeOption[]>([]);
  acquisitionTypeFilterOptions = signal<AcquisitionTypeOption[]>([]);
  assetConfig = signal<AssetConfigSettings | null>(null);
  defaultValues = signal<DefaultValues | null>(null);

  // Computed field for status styling  
  isActiveStatus = computed(() => {
    const currentStatus = this.assetForm?.get('status')?.value;
    const defaults = this.defaultValues();
    return currentStatus === defaults?.defaultStatus;
  });

  // Constants
  readonly displayedColumns = [
    'select', 'name', 'assetType', 'make', 'model', 'serialNumber', 
    'itAssetCode', 'status', 'ownerType', 'currentUser', 'acquisitionType', 
    'actions'  
  ];
  
  // Computed property for item size (from dynamic config)
  itemSize = computed(() => this.assetConfig()?.itemSize || 80);

  // Private subjects
  private destroy$ = new Subject<void>();
  private searchSubject = new BehaviorSubject<string>('');
  private filterSubject = new BehaviorSubject<AssetFilterOptions>({});

  // Injected services
  private assetService = inject(AssetService);
  private assignmentService = inject(AssignmentService);
  private configService = inject(ConfigurationService);
  private dialog = inject(MatDialog);
  private fb = inject(FormBuilder);
  private cdr = inject(ChangeDetectorRef);

  constructor() {
    this.initializeForms();
    this.setupReactiveSearch();
    this.setupFormDependencies();
  }

  ngOnInit(): void {
    this.initializeNavigation();
    this.loadConfiguration();
    this.initializeForms();
    this.setupFormDependencies();
    this.setupReactiveSearch();
    this.setupSubscriptions();
    this.loadInitialData();
    
    // ✅ DEBUG: Test status mapping on component initialization
    this.debugStatusMapping();
  }

  private initializeNavigation(): void {
    this.navigationItems = [
      {
        label: 'Dashboard',
        route: '/dashboard',
        icon: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2H5a2 2 0 00-2 2v10z"></path>
        </svg>`
      },
      {
        label: 'Assets',
        route: '/assets',
        icon: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
        </svg>`
      },
      {
        label: 'Asset Models',
        route: '/asset-models',
        icon: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
        </svg>`
      },
      {
        label: 'Asset POs',
        route: '/asset-pos',
        icon: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
        </svg>`
      },
      {
        label: 'Vendors',
        route: '/vendors',
        icon: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path>
        </svg>`
      },
      {
        label: 'OS & Versions',
        route: '/os-versions',
        icon: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
        </svg>`
      },
      {
        label: 'Users',
        route: '/users',
        icon: `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197m13.5-9a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z"></path>
        </svg>`
      }
    ];
  }

  onNavigationClick(item: NavigationItem): void {
    console.log('Navigation clicked:', item);
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  // Configuration loading
  private loadConfiguration(): void {
    this.configService.loadConfiguration().subscribe({
      next: (config) => {
        this.statusOptions.set(this.configService.getAssetStatuses());
        this.statusFilterOptions.set(this.configService.getAssetStatusesForFilter());
        this.ownerTypeOptions.set(this.configService.getOwnerTypes());
        this.ownerTypeFilterOptions.set(this.configService.getOwnerTypesForFilter());
        this.acquisitionTypeOptions.set(this.configService.getAcquisitionTypes());
        this.acquisitionTypeFilterOptions.set(this.configService.getAcquisitionTypesForFilter());
        this.assetConfig.set(this.configService.getAssetConfig());
        this.defaultValues.set(this.configService.getDefaultValues());
        
        // Update page size from configuration
        const configSettings = this.configService.getAssetConfig();
        this.pageSize.set(configSettings.pageSize as any);
        
        // Reinitialize forms with dynamic configuration
        this.initializeForms();
      },
      error: (error) => {
        console.error('Failed to load configuration:', error);
        // Fallback to current hardcoded values if configuration fails
        this.initializeForms();
      }
    });
  }

  // Initialization
  private initializeForms(): void {
    // Main asset form
    this.assetForm = this.fb.group({
      assetId: [''],
      name: ['', [Validators.required, Validators.minLength(ASSET_CONFIG.MIN_NAME_LENGTH)]],
      serialNumber: ['', [Validators.required, Validators.minLength(ASSET_CONFIG.MIN_SERIAL_LENGTH)]],
      itAssetCode: [''],
      macAddress: [''],
      ipv4Address: ['', [this.ipv4Validator]],
      status: [ASSET_STATUS.IN_STOCK, Validators.required],
      ownerType: ['', Validators.required],
      acquisitionType: ['', Validators.required],
      currentUserId: [''],
      inventoryLocation: [''],
      typeId: ['', Validators.required],
      makeId: ['', Validators.required],
      modelId: ['', Validators.required],
      osId: [''],
      osVersionId: [''],
      poNumber: [''],
      invoiceNumber: [''],
      acquisitionDate: [''],
      warrantyExpiry: [''],
      extendedWarrantyExpiry: [''],
      leaseEndDate: [''],
      vendorId: [''],
      extendedWarrantyVendorId: [''],
      rentalAmount: [''],
      acquisitionPrice: [''],
      depreciationPct: [''],
      currentPrice: [''],
      minContractPeriod: [''],
      tags: ['']
    });

    // Filter form
    this.filterForm = this.fb.group({
      search: [''],
      status: ['ALL'],       // Use 'ALL' code to match configuration service
      ownership: ['ALL'],    // Use 'ALL' code to match configuration service  
      assetType: [''],       // Default to empty for Asset Type
      vendor: ['']           // Default to empty for Vendor
    });

    // ✅ NEW: User assignment form
    this.userAssignmentForm = this.fb.group({
      userId: ['', Validators.required],
      remarks: ['']
    });

    this.setupFormDependencies();
  }

  private setupFormDependencies(): void {
    // 🔥 REAL-TIME: OS → OS Version dependent dropdown
    this.assetForm.get('osId')?.valueChanges
      .pipe(
        takeUntil(this.destroy$),
        distinctUntilChanged()
      )
      .subscribe(osId => {
        if (osId) {
          this.loadOSVersionsRealTime(osId);
        } else {
          // Clear OS versions when no OS is selected
          this.currentOSVersions.set([]);
          this.assetForm.patchValue({ osVersionId: '' }, { emitEvent: false });
          this.selectedOSName.set('');
          this.osVersionsError.set(null);
        }
      });

    // 🔥 REAL-TIME: Asset Model → Auto-fill Asset Type & Make
    this.assetForm.get('modelId')?.valueChanges
      .pipe(
        takeUntil(this.destroy$),
        distinctUntilChanged()
      )
      .subscribe(modelId => {
        if (modelId) {
          this.autoFillModelDetailsRealTime(modelId);
        } else {
          // Clear auto-populated fields when no model is selected
          this.selectedAssetType.set('');
          this.selectedAssetMake.set('');
          this.modelDetailsError.set(null);
        }
      });

    // 🔥 REAL-TIME: PO Number → Auto-fill Acquisition Details
    // Note: Also handles manual (change) events via onPONumberChange method
    this.assetForm.get('poNumber')?.valueChanges
      .pipe(
        takeUntil(this.destroy$),
        debounceTime(500),
        distinctUntilChanged()
      )
      .subscribe(poNumber => {
        if (poNumber && poNumber.trim()) {
          this.autoFillPODetailsRealTime(poNumber.trim());
        } else {
          // Clear PO-related auto-populated fields
          this.clearPORelatedFields();
          this.poDetailsError.set(null);
          this.poErrorMessage.set(null);
        }
      });

    // 🔥 REAL-TIME: Vendor → Auto-fill Warranty Details
    this.assetForm.get('vendorId')?.valueChanges
      .pipe(
        takeUntil(this.destroy$),
        distinctUntilChanged()
      )
      .subscribe(vendorId => {
        if (vendorId) {
          this.autoFillVendorDetails(vendorId);
        } else {
          // Clear vendor-related auto-populated fields
          this.selectedVendor.set('');
          this.selectedExtendedWarrantyVendor.set('');
          this.vendorWarrantyError.set(null);
        }
      });

    // Auto-populate OS Name when OS Version is selected (display purposes)
    this.assetForm.get('osVersionId')?.valueChanges
      .pipe(takeUntil(this.destroy$))
      .subscribe(osVersionId => {
        if (osVersionId) {
          const osVersion = this.currentOSVersions().find(v => v.id === +osVersionId);
          if (osVersion) {
            this.selectedOSName.set(osVersion.name);
          }
        } else {
          this.selectedOSName.set('');
        }
      });
  }

  private setupReactiveSearch(): void {
    // Search functionality with debouncing
    this.searchSubject.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      takeUntil(this.destroy$)
    ).subscribe(searchTerm => {
      const currentFilters = this.currentFilters();
      this.currentFilters.set({ ...currentFilters, search: searchTerm });
      this.loadAssets();
    });

    // Filter changes
    this.filterSubject.pipe(
      debounceTime(300),
      takeUntil(this.destroy$)
    ).subscribe(filters => {
      this.currentFilters.set(filters);
      this.loadAssets();
    });
  }

  private setupSubscriptions(): void {
    // Asset service subscriptions
    this.assetService.assets$
      .pipe(takeUntil(this.destroy$))
      .subscribe(assets => {
        this.assets.set(assets);
        this.cdr.markForCheck();
      });

    this.assetService.loading$
      .pipe(takeUntil(this.destroy$))
      .subscribe(loading => {
        this.loading.set(loading);
        this.cdr.markForCheck();
      });

    this.assetService.error$
      .pipe(takeUntil(this.destroy$))
      .subscribe(error => {
        if (error) {
          this.showError(error);
        }
      });

    // Filter form changes
    this.filterForm.valueChanges
      .pipe(
        startWith(this.filterForm.value),
        debounceTime(300),
        takeUntil(this.destroy$)
      )
      .subscribe(formValues => {
        // Map form field names to backend parameter names
        const mappedFilters: AssetFilterOptions = {
          search: formValues.search || undefined,
          status: (formValues.status === 'ALL' || formValues.status === 'All') ? undefined : formValues.status,
          ownership: (formValues.ownership === 'ALL' || formValues.ownership === 'All') ? undefined : formValues.ownership,
          typeId: formValues.assetType || undefined,
          vendorId: formValues.vendor || undefined
        };
        
        // Remove undefined values to clean up the filter object
        const cleanFilters = Object.fromEntries(
          Object.entries(mappedFilters).filter(([_, value]) => value !== undefined)
        ) as AssetFilterOptions;
        
        console.log('🔍 Filter form changes:', formValues);
        console.log('🔍 Mapped filters for backend:', cleanFilters);
        
        this.filterSubject.next(cleanFilters);
      });
  }

  // Data Loading
  private async loadInitialData(): Promise<void> {
    this.loading.set(true);
    
    try {
      // Load all required data in parallel for better performance
      const [
        assetTypesData,
        assetModelsData,
        vendorsData,
        usersData,
        operatingSystemsData,
        osVersionsData,
        purchaseOrdersData
      ] = await Promise.all([
        this.assetService.getAssetTypes().toPromise(),
        this.assetService.getAssetModelsWithDetails().toPromise(),
        this.assetService.getVendors().toPromise(),
        this.assetService.getUsers().toPromise(),
        this.assetService.getOperatingSystems().toPromise(),
        this.assetService.getOSVersions().toPromise(),
        this.assetService.getPurchaseOrders().toPromise()
      ]);

      // Set the loaded data
      this.assetTypes.set(assetTypesData || []);
      this.assetModelsWithDetails.set(assetModelsData || []);
      this.vendors.set(vendorsData || []);
      this.users.set(usersData || []);
      this.operatingSystems.set(operatingSystemsData || []);
      this.osVersions.set(osVersionsData || []);
      this.purchaseOrders.set(purchaseOrdersData || []);

      console.log('✅ Initial data loaded successfully');
      console.log('📊 Data summary:', {
        assetTypes: this.assetTypes().length,
        models: this.assetModelsWithDetails().length,
        vendors: this.vendors().length,
        users: this.users().length,
        operatingSystems: this.operatingSystems().length,
        osVersions: this.osVersions().length,
        purchaseOrders: this.purchaseOrders().length
      });

      // ✅ NEW: Load assignment data
      await this.loadInitialAssignmentData();

      // Load assets after all dependencies are loaded
      this.loadAssets();
      
    } catch (error) {
      console.error('❌ Error loading initial data:', error);
      this.showError('Failed to load initial data. Please refresh the page.');
    } finally {
      this.loading.set(false);
    }
  }

  /**
   * ✅ NEW: Load assignment-related data (users and tags)
   */
  private async loadInitialAssignmentData(): Promise<void> {
    try {
      const [activeUsersData, availableTagsData] = await Promise.all([
        this.assignmentService.getAllUsers().toPromise(), // Use getAllUsers() to get all active users
        this.assignmentService.getAvailableTags().toPromise()
      ]);

      this.activeUsers.set(activeUsersData || []);
      this.availableTags.set(availableTagsData || []);

      console.log('✅ Assignment data loaded:', {
        activeUsers: this.activeUsers().length,
        availableTags: this.availableTags().length
      });
      
      // Log user details for debugging
      if (this.activeUsers().length > 0) {
        console.log('📋 Available users for assignment:', this.activeUsers().map(u => ({ id: u.id, name: u.name })));
      } else {
        console.warn('⚠️ No users available for assignment');
      }
    } catch (error) {
      console.error('❌ Error loading assignment data:', error);
      // Don't throw error here, assignment features will just be disabled
    }
  }

  /**
   * ✅ NEW: IPv4 address validator
   */
  private ipv4Validator(control: any) {
    if (!control.value) return null;
    const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (!ipv4Pattern.test(control.value)) {
      return { invalidIpv4: true };
    }
    
    // Check if each octet is between 0-255
    const octets = control.value.split('.');
    for (const octet of octets) {
      const num = parseInt(octet, 10);
      if (num < 0 || num > 255) {
        return { invalidIpv4: true };
      }
    }
    
    return null;
  }

  private loadAssets(): void {
    const filters = this.currentFilters();
    const page = this.currentPage();
    const size = this.pageSize();

    console.log('📋 Loading assets with filters:', {
      filters,
      page,
      size,
      filterKeys: Object.keys(filters),
      filterValues: Object.values(filters)
    });

    // ✅ Enhanced debugging for vendor filtering
    if (filters.vendorId) {
      console.log('🏢 Vendor filter detected:', {
        vendorId: filters.vendorId,
        name: this.getname(Number(filters.vendorId)),
        allVendors: this.vendors().map(v => ({ id: v.id, name: v.name }))
      });
    }

    this.loading.set(true);
    this.assetService.getAllAssets(filters, page, size)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.loading.set(false))
      )
      .subscribe({
        next: (response: PageResponse<Asset>) => {
          console.log('✅ Assets loaded successfully:', {
            totalAssets: response.totalElements,
            assetsCount: response.content.length,
            currentPage: response.page,
            totalPages: response.totalPages,
            appliedFilters: filters
          });

          // ✅ Enhanced debugging for vendor filtering results
          if (filters.vendorId) {
            const vendorAssets = response.content.filter(asset => 
              asset.vendorId?.toString() === filters.vendorId?.toString()
            );
            console.log('🏢 Vendor filtering results:', {
              expectedVendorId: filters.vendorId,
              totalAssetsReturned: response.content.length,
              assetsMatchingVendor: vendorAssets.length,
              vendorAssetsDetails: vendorAssets.map(a => ({
                id: a.assetId,
                name: a.name,
                vendorId: a.vendorId,
                name: this.getname(a.vendorId)
              })),
              allAssetsVendorIds: response.content.map(a => ({
                assetId: a.assetId,
                name: a.name,
                vendorId: a.vendorId,
                name: this.getname(a.vendorId)
              }))
            });
          }

          this.assets.set(response.content);
          this.totalAssets.set(response.totalElements);
          this.cdr.markForCheck();
        },
        error: (error: any) => {
          console.error('❌ Error loading assets:', error);
          this.showError('Failed to load assets. Please try again.');
        }
      });
  }

  private loadOSVersionsByOS(osId: number): void {
    this.assetService.getOSVersionsByOS(osId)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (versions) => {
          this.filteredOSVersions.set(versions || []);
          this.cdr.markForCheck();
        },
        error: (error) => {
          console.error('Error loading OS versions:', error);
        }
      });
  }

  // Auto-fill Logic
  private autoFillModelDetails(modelId: number): void {
    const selectedModel = this.assetModelsWithDetails().find(m => m.id === modelId);
    if (selectedModel) {
      // Auto-populate the read-only Asset Type and Make fields
      this.selectedAssetType.set(selectedModel.typeName);
      this.selectedAssetMake.set(selectedModel.makeName);
    }
  }

  private autoFillPODetails(poNumber: string): void {
    this.assetService.getPOByNumber(poNumber)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (po: AssetPODTO | null) => {
          if (po) {
            this.assetForm.patchValue({
              acquisitionType: po.acquisitionType,
              invoiceNumber: po.invoiceNumber,
              acquisitionPrice: po.acquisitionPrice,
              rentalAmount: po.rentalAmount,
              currentPrice: po.currentPrice,
              depreciationPct: po.depreciationPct,
              leaseEndDate: po.leaseEndDate,
              minContractPeriod: po.minContractPeriod,
              vendorId: po.vendorId,
              ownerType: po.ownerType
            }, { emitEvent: false });

            this.showSuccess(ASSET_MESSAGES.SUCCESS.PO_LOADED);
          }
        },
        error: (error) => {
          console.error('Error loading PO details:', error);
          this.showError(ASSET_MESSAGES.ERROR.PO_NOT_FOUND);
        }
      });
  }

  private autoFillOSDetails(osVersionId: number): void {
    const selectedOSVersion = this.osVersions().find(v => v.id === osVersionId);
    if (selectedOSVersion) {
      // Auto-populate OS ID
      this.assetForm.patchValue({
        osId: selectedOSVersion.osId
      }, { emitEvent: false });

      // Find and set the OS name for display
      const selectedOS = this.operatingSystems().find(os => os.id === selectedOSVersion.osId);
      if (selectedOS) {
        this.selectedOSName.set(selectedOS.name);
      }
    }
  }

  private clearPORelatedFields(): void {
    // Get dynamic default values
    const defaults = this.defaultValues() || { defaultAcquisitionType: 'BOUGHT' };
    
    this.assetForm.patchValue({
      invoiceNumber: '',
      acquisitionType: defaults.defaultAcquisitionType,
      acquisitionDate: '',
      acquisitionPrice: 0,
      rentalAmount: 0,
      leaseEndDate: '',
      vendorId: '',
      extendedWarrantyVendorId: '',
      extendedWarrantyExpiry: '',
      warrantyExpiry: ''
    }, { emitEvent: false });

    // Clear vendor-related display names
    this.selectedVendor.set('');
    this.selectedExtendedWarrantyVendor.set('');
  }

  private autoFillVendorDetails(vendorId: number): void {
    const selectedVendor = this.vendors().find(v => v.id === vendorId);
    if (selectedVendor) {
      this.selectedVendor.set(selectedVendor.name);
      
      // Auto-populate extended warranty vendor (typically same as main vendor)
      this.assetForm.patchValue({
        extendedWarrantyVendorId: vendorId
      }, { emitEvent: false });
      
      this.selectedExtendedWarrantyVendor.set(selectedVendor.name);

      // Auto-populate warranty expiry dates (example: 1 year from acquisition)
      const acquisitionDate = this.assetForm.get('acquisitionDate')?.value;
      if (acquisitionDate) {
        const warrantyDate = new Date(acquisitionDate);
        warrantyDate.setFullYear(warrantyDate.getFullYear() + 1);
        
        const extendedWarrantyDate = new Date(acquisitionDate);
        extendedWarrantyDate.setFullYear(extendedWarrantyDate.getFullYear() + 2);

        this.assetForm.patchValue({
          warrantyExpiry: warrantyDate.toISOString().split('T')[0],
          extendedWarrantyExpiry: extendedWarrantyDate.toISOString().split('T')[0]
        }, { emitEvent: false });
      }
    }
  }

  // ===== REAL-TIME DEPENDENT DROPDOWN METHODS =====

  // 🔥 REAL-TIME: Load OS Versions by OS ID with loading states
  private loadOSVersionsRealTime(osId: number): void {
    this.osVersionsLoading.set(true);
    this.osVersionsError.set(null);
    
    this.assetService.getOSVersionsByOSRealTime(osId)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.osVersionsLoading.set(false))
      )
      .subscribe({
        next: (versions: OSVersion[]) => {
          this.currentOSVersions.set(versions);
          this.cdr.markForCheck();
        },
        error: (error) => {
          console.error('Error loading OS versions:', error);
          this.osVersionsError.set('Failed to load OS versions');
          this.currentOSVersions.set([]);
        }
      });
  }

  // 🔥 REAL-TIME: Auto-fill Asset Model Details with API call
  private autoFillModelDetailsRealTime(modelId: number): void {
    this.modelDetailsLoading.set(true);
    this.modelDetailsError.set(null);
    
    this.assetService.getAssetModelDetails(modelId)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.modelDetailsLoading.set(false))
      )
      .subscribe({
        next: (modelDetails: AssetModelDetails) => {
          // Auto-populate the read-only Asset Type and Make fields
          this.selectedAssetType.set(modelDetails.assetTypeName);
          this.selectedAssetMake.set(modelDetails.makeName);
          
          // Auto-populate hidden form fields for backend
          this.assetForm.patchValue({
            typeId: modelDetails.typeId,
            makeId: modelDetails.makeId
          }, { emitEvent: false });
          
          this.cdr.markForCheck();
        },
        error: (error) => {
          console.error('Error loading model details:', error);
          this.modelDetailsError.set('Failed to load model details');
          this.selectedAssetType.set('');
          this.selectedAssetMake.set('');
        }
      });
  }

  // 🔥 REAL-TIME: Auto-fill PO Details with API call
  private autoFillPODetailsRealTime(poNumber: string): void {
    this.poDetailsLoading.set(true);
    this.poDetailsError.set(null);
    this.poErrorMessage.set(null);
    
    this.assetService.getPODetailsRealTime(poNumber)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.poDetailsLoading.set(false))
      )
      .subscribe({
        next: (poDetails: PODetails) => {
          // Auto-populate all PO-related fields
          this.assetForm.patchValue({
            acquisitionType: poDetails.acquisitionType,
            acquisitionDate: poDetails.acquisitionDate,
            invoiceNumber: poDetails.invoiceNumber,
            acquisitionPrice: poDetails.acquisitionPrice,
            vendorId: poDetails.vendorId,
            ownerType: poDetails.ownerType,
            leaseEndDate: poDetails.leaseEndDate,
            minContractPeriod: poDetails.minContractPeriod,
            rentalAmount: poDetails.rentalAmount,
            currentPrice: poDetails.currentPrice
          }, { emitEvent: false });

          // Set vendor name for display
          const vendor = this.vendors().find(v => v.id === poDetails.vendorId);
          if (vendor) {
            this.selectedVendor.set(vendor.name);
          }

          this.showSuccess(ASSET_MESSAGES.SUCCESS.PO_LOADED);
          this.cdr.markForCheck();
        },
        error: (error) => {
          console.error('Error loading PO details:', error);
          this.poDetailsError.set('PO not found or invalid');
          this.poErrorMessage.set(error.message || 'Failed to load PO details');
          this.showError(ASSET_MESSAGES.ERROR.PO_NOT_FOUND);
        }
      });
  }

  // ✅ NEW: Enhanced Auto-fill PO Details method using getPODetailsByNumber
  autoFillPODetailsEnhanced(poNumber: string): void {
    this.poDetailsLoading.set(true);
    this.poDetailsError.set(null);
    this.poErrorMessage.set(null);
    
    this.assetService.getPODetailsByNumber(poNumber)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.poDetailsLoading.set(false))
      )
      .subscribe({
        next: (poDetails: PODetails) => {
          // Auto-populate all PO-related fields
          this.assetForm.patchValue({
            acquisitionType: poDetails.acquisitionType,
            acquisitionDate: poDetails.acquisitionDate,
            invoiceNumber: poDetails.invoiceNumber,
            acquisitionPrice: poDetails.acquisitionPrice,
            vendorId: poDetails.vendorId,
            ownerType: poDetails.ownerType,
            leaseEndDate: poDetails.leaseEndDate,
            minContractPeriod: poDetails.minContractPeriod,
            rentalAmount: poDetails.rentalAmount,
            currentPrice: poDetails.currentPrice
          }, { emitEvent: false });

          // Set vendor name for display
          const vendor = this.vendors().find(v => v.id === poDetails.vendorId);
          if (vendor) {
            this.selectedVendor.set(vendor.name);
          }

          // Clear any previous errors
          this.poErrorMessage.set(null);
          this.poDetailsError.set(null);
          
          this.showSuccess(ASSET_MESSAGES.SUCCESS.PO_LOADED);
          this.cdr.markForCheck();
        },
        error: (error) => {
          console.error('Error in autoFillPODetailsEnhanced:', error);
          const errorMsg = error.message || 'Failed to load PO details';
          this.poDetailsError.set(errorMsg);
          this.poErrorMessage.set(errorMsg);
          this.showError(errorMsg);
        }
      });
  }



  // 🔥 REAL-TIME: Auto-fill Vendor Warranty Details with API call
  private autoFillVendorDetailsRealTime(vendorId: number): void {
    this.vendorWarrantyLoading.set(true);
    this.vendorWarrantyError.set(null);
    
    this.assetService.getVendorWarrantyDetails(vendorId)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.vendorWarrantyLoading.set(false))
      )
      .subscribe({
        next: (warrantyDetails: VendorWarrantyDetails) => {
          // Auto-populate vendor display name
          this.selectedVendor.set(warrantyDetails.name);
          
          // Auto-populate extended warranty details
          this.assetForm.patchValue({
            extendedWarrantyVendorId: warrantyDetails.extendedWarrantyVendorId
          }, { emitEvent: false });
          
          this.selectedExtendedWarrantyVendor.set(warrantyDetails.extendedWarrantyVendor);

          // Auto-calculate warranty expiry dates based on acquisition date
          const acquisitionDate = this.assetForm.get('acquisitionDate')?.value;
          if (acquisitionDate) {
            const baseDate = new Date(acquisitionDate);
            
            // Standard warranty
            const warrantyDate = new Date(baseDate);
            warrantyDate.setMonth(warrantyDate.getMonth() + warrantyDetails.defaultWarrantyMonths);
            
            // Extended warranty
            const extendedWarrantyDate = new Date(baseDate);
            extendedWarrantyDate.setMonth(extendedWarrantyDate.getMonth() + warrantyDetails.extendedWarrantyMonths);

            this.assetForm.patchValue({
              warrantyExpiry: warrantyDate.toISOString().split('T')[0],
              extendedWarrantyExpiry: extendedWarrantyDate.toISOString().split('T')[0]
            }, { emitEvent: false });
          }

          this.cdr.markForCheck();
        },
        error: (error) => {
          console.error('Error loading vendor warranty details:', error);
          this.vendorWarrantyError.set('Failed to load warranty details');
          
          // Fallback to basic vendor display
          const vendor = this.vendors().find(v => v.id === vendorId);
          if (vendor) {
            this.selectedVendor.set(vendor.name);
          }
        }
      });
  }

  // CRUD Operations
  openAddAssetModal(): void {
    this.selectedAsset.set(null);
    this.isEditMode.set(false);
    this.assetForm.reset();
    
    // Get dynamic default values
    const defaults = this.defaultValues() || { 
      defaultStatus: 'ACTIVE', 
      defaultOwnerType: 'CELCOM', 
      defaultAcquisitionType: 'BOUGHT' 
    };
    
    this.assetForm.patchValue({
      status: defaults.defaultStatus,
      ownerType: defaults.defaultOwnerType,
      acquisitionType: defaults.defaultAcquisitionType,
      currentUserId: null  // Set to null on creation
    });
    // Clear the auto-populated fields
    this.selectedAssetType.set('');
    this.selectedAssetMake.set('');
    this.isFormModalOpen.set(true);
  }

  openEditAssetModal(asset: Asset): void {
    this.selectedAsset.set(asset);
    this.isEditMode.set(true);
    
    // Set the asset ID properly for editing
    this.assetForm.patchValue({
      ...asset,
      assetId: asset.assetId // Ensure asset_id is included for PUT requests
    });
    
    // Auto-populate dependent fields based on current values
    if (asset.modelId) {
      this.autoFillModelDetails(asset.modelId);
    }
    
    if (asset.osVersionId) {
      this.autoFillOSDetails(asset.osVersionId);
    }
    
    if (asset.vendorId) {
      this.autoFillVendorDetails(asset.vendorId);
    }

    this.isFormModalOpen.set(true);
  }

  closeAssetModal(): void {
    this.isFormModalOpen.set(false);
    this.selectedAsset.set(null);
    this.assetForm.reset();
  }

  onSubmitAsset(): void {
    if (this.assetForm.valid) {
      const formData = { ...this.assetForm.value };
      const isEdit = this.isEditMode();
      
      // Ensure asset_id is properly set for updates
      if (isEdit) {
        formData.assetId = this.selectedAsset()!.assetId!;
      } else {
        // For creation, remove assetId or set to null
        delete formData.assetId;
      }

      const operation = isEdit 
        ? this.assetService.updateAsset(formData.assetId, formData)
        : this.assetService.createAsset(formData);

      operation.pipe(takeUntil(this.destroy$))
        .subscribe({
          next: (asset) => {
            const message = isEdit 
              ? ASSET_MESSAGES.SUCCESS.UPDATE 
              : ASSET_MESSAGES.SUCCESS.CREATE;
            this.showSuccess(message);
            this.closeAssetModal();
            this.loadAssets();
          },
          error: (error) => {
            console.error('Error saving asset:', error);
            this.showError('Failed to save asset');
          }
        });
    } else {
      this.markFormGroupTouched(this.assetForm);
    }
  }

  deleteAsset(asset: Asset): void {
    if (confirm(`Are you sure you want to delete "${asset.name}"?`)) {
      this.assetService.deleteAsset(asset.assetId!)
        .pipe(takeUntil(this.destroy$))
        .subscribe({
          next: () => {
            this.showSuccess(ASSET_MESSAGES.SUCCESS.DELETE);
            this.loadAssets();
          },
          error: (error) => {
            console.error('Error deleting asset:', error);
            this.showError('Failed to delete asset');
          }
        });
    }
  }

  // Bulk Operations
  bulkDeleteSelected(): void {
    const selectedAssets = this.selection.selected;
    if (selectedAssets.length === 0) return;

    const assetNames = selectedAssets.map(a => a.name).join(', ');
    if (confirm(`Are you sure you want to delete ${selectedAssets.length} assets: ${assetNames}?`)) {
      const ids = selectedAssets.map(a => a.assetId!);
      
      // Since bulkDeleteAssets is not in the existing service, use individual deletes
      const deletePromises = ids.map(id => this.assetService.deleteAsset(id).toPromise());
      
      Promise.all(deletePromises).then(() => {
        this.showSuccess(`Successfully deleted ${selectedAssets.length} assets`);
        this.selection.clear();
        this.loadAssets();
      }).catch((error) => {
        console.error('Error bulk deleting assets:', error);
        this.showError('Failed to delete selected assets');
      });
    }
  }

  // Table and Selection Management
  isAllSelected(): boolean {
    const numSelected = this.selection.selected.length;
    const numRows = this.filteredAssets().length;
    return numSelected === numRows && numRows > 0;
  }

  masterToggle(): void {
    if (this.isAllSelected()) {
      this.selection.clear();
    } else {
      this.filteredAssets().forEach(row => this.selection.select(row));
    }
  }

  // Pagination Methods
  onPageChange(event: PageEvent): void {
    this.currentPage.set(event.pageIndex);
    this.pageSize.set(event.pageSize as typeof ASSET_CONFIG.PAGE_SIZE);
    this.loadAssets();
  }

  // Add missing goToPage method
  goToPage(page: number): void {
    this.currentPage.set(page);
    this.loadAssets();
  }

  // Search and Filter
  onSearchChange(searchTerm: string): void {
    this.searchSubject.next(searchTerm);
  }

  /**
   * Handle Asset Type filter change - now handled by form value changes
   * This method is kept for backward compatibility but the main filtering
   * logic is now handled in setupSubscriptions()
   */
  onAssetTypeFilterChange(typeId: string): void {
    console.log('🔍 Asset Type filter changed:', typeId);
    // The filtering is now automatically handled by the form valueChanges subscription
    // This method can be removed if no other logic is needed
  }

  clearFilters(): void {
    console.log('🔄 Clearing all filters');
    
    this.filterForm.reset({
      search: '',
      status: 'ALL',       // Use 'ALL' code to match configuration service
      ownership: 'ALL',    // Use 'ALL' code to match configuration service
      assetType: '',
      vendor: ''
    });
    
    // Reset pagination to first page
    this.currentPage.set(0);
    
    // Clear current filters signal
    this.currentFilters.set({});
    
    console.log('✅ Filters cleared, showing all assets');
  }

  // Add missing methods that might be called from template
  triggerChangeDetection(): void {
    this.cdr.markForCheck();
  }

  applyFiltersAndPagination(): void {
    const filterValue = this.filterForm.value;
    this.currentFilters.set(filterValue);
    this.currentPage.set(0); // Reset to first page when filtering
    this.loadAssets();
  }

  // Utility Methods
  private markFormGroupTouched(formGroup: FormGroup): void {
    Object.keys(formGroup.controls).forEach(key => {
      const control = formGroup.get(key);
      control?.markAsTouched();
    });
  }

  // ✅ NEW: Toast notification system
  toastMessage = signal<string>('');
  toastType = signal<'success' | 'error' | 'info'>('info');
  showToast = signal(false);

  private showSuccess(message: string): void {
    console.log('Success:', message);
    this.displayToast(message, 'success');
  }

  private showError(message: string): void {
    console.error('Error:', message);
    this.displayToast(message, 'error');
  }

  private displayToast(message: string, type: 'success' | 'error' | 'info'): void {
    this.toastMessage.set(message);
    this.toastType.set(type);
    this.showToast.set(true);
    
    // Auto-hide after 5 seconds
    setTimeout(() => {
      this.hideToast();
    }, 5000);
  }

  hideToast(): void {
    this.showToast.set(false);
  }

  /**
   * ✅ Get current user ID for status changes
   * Using hardcoded ID 1 for now as requested
   */
  private getCurrentUserId(): number | null {
    // ✅ Using hardcoded user ID 1 as requested
    return 1;
    
    // TODO: Later integrate with actual auth service
    // Example: return this.authService.getCurrentUserId() || null;
  }

  /**
   * ✅ Auto-refresh assets data after status change
   * Ensures display is synchronized with backend
   */
  refreshAssetsData(): void {
    console.log('🔄 Refreshing assets data...');
    
    // Reload assets with current filters
    const currentFilters = this.currentFilters();
    const currentPageIndex = this.currentPage();
    const currentPageSize = this.pageSize();
    
    this.assetService.getAllAssets(currentFilters, currentPageIndex, currentPageSize).subscribe({
      next: (response) => {
        this.assets.set(response.content);
        this.totalAssets.set(response.totalElements);
        console.log('✅ Assets data refreshed successfully');
      },
      error: (error) => {
        console.error('❌ Error refreshing assets data:', error);
        this.displayToast('Failed to refresh asset data', 'error');
      }
    });
  }

  getFieldError(fieldName: string): string {
    const field = this.assetForm.get(fieldName);
    if (field && field.invalid && (field.dirty || field.touched)) {
      if (field.errors?.['required']) {
        return `${fieldName} is required`;
      }
      if (field.errors?.['minlength']) {
        return `${fieldName} must be at least ${field.errors['minlength'].requiredLength} characters`;
      }
      if (field.errors?.['pattern']) {
        return `${fieldName} format is invalid`;
      }
      if (field.errors?.['min']) {
        return `${fieldName} must be greater than or equal to ${field.errors['min'].min}`;
      }
      if (field.errors?.['max']) {
        return `${fieldName} must be less than or equal to ${field.errors['max'].max}`;
      }
    }
    return '';
  }

  // Helper methods for template
  getUserName(userId?: number): string {
    if (!userId) return 'Unassigned';
    const user = this.users().find(u => u.id === userId);
    return user ? user.name : 'Unknown User';
  }

  getname(vendorId?: number): string {
    if (!vendorId) return 'N/A';
    const vendor = this.vendors().find(v => v.id === vendorId);
    return vendor ? vendor.name : 'Unknown Vendor';
  }

  getAssetTypeName(typeId?: number): string {
    if (!typeId) return 'N/A';
    const model = this.assetModelsWithDetails().find(m => m.typeId === typeId);
    return model ? model.typeName : 'Unknown Type';
  }

  getMakeName(makeId?: number): string {
    const model = this.assetModelsWithDetails().find(m => m.makeId === makeId);
    return model?.makeName || 'Unknown Make';
  }

  getModelName(modelId?: number): string {
    if (!modelId) return 'N/A';
    const model = this.assetModelsWithDetails().find(m => m.id === modelId);
    return model ? model.name : 'Unknown Model';
  }

  getOSName(osId?: number): string {
    if (!osId) return 'N/A';
    const os = this.operatingSystems().find(o => o.id === osId);
    return os ? os.name : 'Unknown OS';
  }

  getOSVersionName(osVersionId?: number): string {
    const version = this.osVersions().find(v => v.id === osVersionId);
    return version ? version.versionNumber : 'Unknown';
  }

  // ✅ TrackBy functions for performance optimization
  trackByAssetId(index: number, asset: Asset): number {
    return asset.assetId || index;
  }

  // ✅ NEW: TrackBy functions for dropdowns as requested
  trackById(index: number, item: any): number {
    return item.id || index;
  }

  trackByOSVersionId(index: number, version: OSVersion): number {
    return version.id || index;
  }

  trackByVendorId(index: number, vendor: Vendor): number {
    return vendor.id || index;
  }

  trackByUserId(index: number, user: User): number {
    return user.id || index;
  }

  trackByModelId(index: number, model: AssetModelWithDetails): number {
    return model.id || index;
  }

  trackByOSId(index: number, os: OperatingSystem): number {
    return os.id || index;
  }

  // Dynamic status styling methods using configuration service
  getStatusClass(status: string): string {
    switch (status) {
      case 'ACTIVE':
        return 'bg-green-100 text-green-800';
      case 'IN_REPAIR':
        return 'bg-orange-100 text-orange-800';
      case 'BROKEN':
        return 'bg-red-100 text-red-800';
      case 'CEASED':
        return 'bg-gray-200 text-gray-700';
      case 'IN_STOCK':
        return 'bg-blue-100 text-blue-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  }

  getStatusBadge(status: string): { class: string; icon: string; label: string } {
    const displayName = this.getStatusDisplayName(status);
    
    switch (status) {
      case 'ACTIVE':
        return {
          class: 'bg-green-100 text-green-800 border border-green-200',
          icon: '●', // Green dot
          label: displayName
        };
      case 'IN_REPAIR':
        return {
          class: 'bg-orange-100 text-orange-800 border border-orange-200',
          icon: '⚠', // Warning icon
          label: displayName
        };
      case 'BROKEN':
        return {
          class: 'bg-red-100 text-red-800 border border-red-200',
          icon: '✕', // X mark
          label: displayName
        };
      case 'CEASED':
        return {
          class: 'bg-gray-200 text-gray-700 border border-gray-300',
          icon: '⊘', // Prohibition sign
          label: displayName
        };
      case 'IN_STOCK':
        return {
          class: 'bg-blue-100 text-blue-800 border border-blue-200',
          icon: '📦', // Package icon
          label: displayName
        };
      default:
        return {
          class: 'bg-gray-100 text-gray-800 border border-gray-200',
          icon: '?',
          label: displayName
        };
    }
  }

  // ✅ NEW: Asset Status Change Methods

  /**
   * Open status change modal with remarks
   */
  openStatusChangeModal(asset: Asset, newStatus: string): void {
    // If status is the same, do nothing
    if (asset.status === newStatus) {
      return;
    }

    this.selectedAssetForStatusChange.set(asset);
    this.pendingStatusChange.set(newStatus);
    this.showStatusChangeModal.set(true);
    this.statusChangeError.set(null);
  }

  /**
   * Confirm status change with remarks and enhanced user feedback
   */
  confirmStatusChange(remarks?: string): void {
    const asset = this.selectedAssetForStatusChange();
    const newStatus = this.pendingStatusChange();
    
    if (asset && newStatus) {
      this.onStatusChange(asset, newStatus, remarks);
      this.showStatusChangeModal.set(false);
      
      // Show immediate feedback to user
      const trimmedRemarks = remarks?.trim();
      const remarksText = trimmedRemarks ? ` (${trimmedRemarks})` : '';
      this.displayToast(
        `🔄 Processing status change for "${asset.name}" to "${newStatus}"${remarksText}`,
        'info'
      );
    }
  }

  /**
   * Cancel status change
   */
  cancelStatusChange(): void {
    this.showStatusChangeModal.set(false);
    this.selectedAssetForStatusChange.set(null);
    this.pendingStatusChange.set('');
    this.statusChangeError.set(null);
  }

  /**
   * ✅ Change asset status with validation and automatic rules
   * Integrates with backend PUT /api/assets/{id}/status
   */
  onStatusChange(asset: Asset, newStatus: string, remarks?: string): void {
    // ✅ COMPREHENSIVE DEBUG LOGGING AS REQUESTED
    console.log('🔄 Starting status change process:', {
      assetId: asset.assetId,
      assetName: asset.name,
      currentStatus: asset.status,
      newStatus,
      remarks,
      changedById: 1 // ✅ Using hardcoded user ID 1 as requested
    });

    // ✅ VALIDATE newStatus TYPE AND VALUE
    console.log('🔍 Status validation checks:');
    console.log('  - newStatus type:', typeof newStatus);
    console.log('  - newStatus length:', newStatus?.length || 0);
    console.log('  - newStatus value:', JSON.stringify(newStatus));
    
    // Check for whitespace/trim issues
    const trimmedStatus = newStatus?.trim();
    console.log('  - trimmed status:', JSON.stringify(trimmedStatus));
    console.log('  - has leading/trailing spaces:', newStatus !== trimmedStatus);
    
    // Validate against allowed enum values
    const validStatuses = Object.values(ASSET_STATUS);
    console.log('  - valid statuses:', validStatuses);
    console.log('  - is valid status:', validStatuses.includes(newStatus as any));
    
    // Check if newStatus is null/undefined
    if (!newStatus || newStatus === null || newStatus === undefined) {
      console.error('❌ Status validation failed: newStatus is null/undefined');
      this.statusChangeError.set('Status value is missing');
      return;
    }

    // Frontend validation
    const validation = this.assetService.validateStatusChange(newStatus, asset.currentUserId);
    if (!validation.isValid) {
      this.statusChangeError.set(validation.error || 'Invalid status change');
      console.warn('⚠️ Validation failed:', validation.error);
      return;
    }

    // ✅ Proper user context handling with null fallback
    const currentUserId = this.getCurrentUserId(); // Get from auth service or null
    const request: AssetStatusChangeRequest = {
      assetId: asset.assetId!,
      newStatus: trimmedStatus, // ✅ Use trimmed status to avoid whitespace issues
      changedById: currentUserId, // Can be null if no user context
      remarks: remarks?.trim() || null, // Ensure null instead of empty string
      currentUserId: asset.currentUserId
    };

    // ✅ COMPREHENSIVE PAYLOAD LOGGING AS REQUESTED
    console.log('📤 Status Update Payload:', JSON.stringify(request));
    console.log('📤 Payload breakdown:');
    console.log('  - assetId:', request.assetId, '(type:', typeof request.assetId, ')');
    console.log('  - newStatus:', JSON.stringify(request.newStatus), '(type:', typeof request.newStatus, ', length:', request.newStatus?.length, ')');
    console.log('  - changedById:', request.changedById, '(type:', typeof request.changedById, ')');
    console.log('  - remarks:', JSON.stringify(request.remarks), '(type:', typeof request.remarks, ')');
    console.log('  - currentUserId:', request.currentUserId, '(type:', typeof request.currentUserId, ')');

    this.statusChangeLoading.set(true);
    this.statusChangeError.set(null);

    this.assetService.changeAssetStatus(request).subscribe({
      next: (response) => {
        console.log('✅ Status change successful:', response);
        this.statusChangeLoading.set(false);
        this.showSuccess(response.message);
        
        // ✅ Update the asset in the local list immediately
        const currentAssets = this.assets();
        const index = currentAssets.findIndex(a => a.assetId === asset.assetId);
        if (index !== -1) {
          currentAssets[index] = response.asset;
          this.assets.set([...currentAssets]);
          console.log('🔄 Asset list updated locally:', response.asset.name);
        }

        // ✅ Update status history for audit trail
        this.statusHistory.set(response.statusHistory);

        // ✅ Auto-refresh display: Reload assets to ensure sync with backend
        this.refreshAssetsData();

        // ✅ Enhanced success notification with details
        const remarksText = remarks?.trim() ? ` (Remarks: ${remarks.trim()})` : '';
        this.displayToast(
          `✅ Success! "${asset.name}" status changed to "${newStatus}"${remarksText}`,
          'success'
        );

        // ✅ Update filters and pagination to reflect any changes
        this.applyFiltersAndPagination();
      },
      error: (error) => {
        console.error('❌ Status change error details:');
        console.error('  - Error object:', error);
        console.error('  - Error message:', error.message);
        console.error('  - Error status:', error.status);
        console.error('  - Error statusText:', error.statusText);
        console.error('  - Full error response:', error.error);
        
        this.statusChangeLoading.set(false);
        this.statusChangeError.set(error.message || 'Failed to change status');
        
        // ✅ Enhanced error notification with asset details
        this.displayToast(
          `❌ Failed to change status for "${asset.name}". ${error.message || 'Please try again.'}`,
          'error'
        );
        
        console.error('❌ Status change error:', error);
      }
    });
  }

  /**
   * ✅ NEW: Open status history modal
   */
  openStatusHistoryModal(asset: Asset): void {
    this.statusHistoryModalAsset.set({
      id: asset.assetId!,
      name: asset.name,
      serial: asset.serialNumber || ''
    });
    this.showStatusHistoryModal.set(true);
  }

  /**
   * ✅ NEW: Close status history modal
   */
  closeStatusHistoryModal(): void {
    this.showStatusHistoryModal.set(false);
    this.statusHistoryModalAsset.set(null);
  }

  /**
   * Load asset status history for audit trail (legacy method for backward compatibility)
   */
  loadStatusHistory(assetId: number): void {
    this.statusHistoryLoading.set(true);
    
    this.assetService.getAssetStatusHistory(assetId).subscribe({
      next: (history) => {
        this.statusHistoryLoading.set(false);
        // Convert DTO to full history objects for backward compatibility
        const fullHistory: AssetStatusHistory[] = history.map(dto => ({
          assetId: assetId,
          status: dto.status,
          changedById: dto.changedById,
          changeDate: dto.changeDate,
          remarks: dto.remarks || undefined
        }));
        this.statusHistory.set(fullHistory);
        this.showStatusHistory.set(true);
      },
      error: (error) => {
        this.statusHistoryLoading.set(false);
        this.showError('Failed to load status history: ' + error.message);
      }
    });
  }

  /**
   * Toggle status history visibility (legacy method)
   */
  toggleStatusHistory(asset: Asset): void {
    if (this.showStatusHistory()) {
      this.showStatusHistory.set(false);
    } else {
      this.loadStatusHistory(asset.assetId!);
    }
  }

  /**
   * Check if status requires validation (for UI feedback)
   */
  requiresEmployee(status: string): boolean {
    return this.assetService.requiresUserAssignment(status);
  }

  /**
   * Check if status will unassign user (for UI feedback)
   */
  willUnassignUser(status: string): boolean {
    return this.assetService.shouldUnassignUser(status);
  }

  /**
   * Get status change validation message for UI
   */
  getStatusValidationMessage(newStatus: string, asset: Asset): string | null {
    const validation = this.assetService.validateStatusChange(newStatus, asset.currentUserId);
    return validation.isValid ? null : validation.error || null;
  }

  /**
   * Format date for status history display
   */
  formatStatusDate(dateString: string): string {
    return new Date(dateString).toLocaleString();
  }

  /**
   * Get user name for status history display
   */
  getStatusHistoryUserName(userId: number): string {
    const user = this.users().find(u => u.id === userId);
    return user ? user.name : `User ${userId}`;
  }

  /**
   * ✅ NEW: Get display name for status (maps API values to user-friendly names)
   */
  getStatusDisplayName(status?: string): string {
    if (!status) return 'Unknown';
    
    // Find the display name from our mapping
    const statusKey = Object.keys(ASSET_STATUS).find(key => 
      ASSET_STATUS[key as keyof typeof ASSET_STATUS] === status
    );
    
    if (statusKey) {
      return ASSET_STATUS_DISPLAY[statusKey as keyof typeof ASSET_STATUS_DISPLAY];
    }
    
    // Fallback: convert status to title case
    return status.split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }

  /**
   * ✅ DEBUG: Test status mapping to ensure API/Display values are correct
   */
  private debugStatusMapping(): void {
    console.log('🔍 DEBUG: Status Mapping Test');
    console.log('='.repeat(50));
    
    console.log('📋 ASSET_STATUS (API values):');
    Object.entries(ASSET_STATUS).forEach(([key, value]) => {
      console.log(`  ${key}: "${value}"`);
    });
    
    console.log('\n📋 ASSET_STATUS_DISPLAY (UI values):');
    Object.entries(ASSET_STATUS_DISPLAY).forEach(([key, value]) => {
      console.log(`  ${key}: "${value}"`);
    });
    
    console.log('\n📋 Dropdown Options:');
    const options = this.statusDropdownOptions();
    options.forEach(option => {
      console.log(`  code: "${option.code}" → name: "${option.name}"`);
    });
    
    console.log('\n🧪 Testing getStatusDisplayName():');
    Object.values(ASSET_STATUS).forEach(apiValue => {
      const displayName = this.getStatusDisplayName(apiValue);
      console.log(`  "${apiValue}" → "${displayName}"`);
    });
    
    console.log('='.repeat(50));
  }

  // ✅ NEW: USER ASSIGNMENT METHODS

  /**
   * Open user assignment modal for an asset
   */
  openUserAssignmentModal(asset: Asset): void {
    console.log('🔗 Opening user assignment modal for asset:', asset.assetId);
    
    this.selectedAssetForUserAssignment.set(asset);
    this.showUserAssignmentModal.set(true);
    this.userAssignmentError.set(null);
    
    // Reset form
    this.userAssignmentForm.reset();
    
    // Load current assignment
    this.loadCurrentUserAssignment(asset.assetId!);
  }

  /**
   * Close user assignment modal
   */
  closeUserAssignmentModal(): void {
    this.showUserAssignmentModal.set(false);
    this.selectedAssetForUserAssignment.set(null);
    this.currentUserAssignment.set(null);
    this.userAssignmentError.set(null);
    this.userAssignmentForm.reset();
  }

  /**
   * Load current user assignment for an asset
   */
  private loadCurrentUserAssignment(assetId: number): void {
    this.userAssignmentLoading.set(true);
    
    this.assignmentService.getCurrentUserAssignment(assetId)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.userAssignmentLoading.set(false))
      )
      .subscribe({
        next: (assignment) => {
          this.currentUserAssignment.set(assignment);
          console.log('📥 Current user assignment:', assignment);
          
          // Prefill form if assignment exists
          if (assignment) {
            this.userAssignmentForm.patchValue({
              userId: assignment.userId,
              remarks: assignment.remarks || ''
            });
            console.log('✅ Form prefilled with assignment data:', {
              userId: assignment.userId,
              remarks: assignment.remarks
            });
          } else {
            // Clear form if no assignment
            this.userAssignmentForm.reset();
            console.log('ℹ️ No current assignment found, form cleared');
          }
        },
        error: (error) => {
          console.error('❌ Error loading current assignment:', error);
          // Don't show error for 404 - it's expected when no assignment exists
          if (error.status !== 404) {
            this.userAssignmentError.set('Failed to load current assignment');
          } else {
            console.log('ℹ️ No assignment found (404) - this is normal');
            this.currentUserAssignment.set(null);
            this.userAssignmentForm.reset();
          }
        }
      });
  }

  /**
   * Assign user to asset using new API endpoint
   */
  onAssignUser(): void {
    if (this.userAssignmentForm.valid) {
      const selectedAsset = this.selectedAssetForUserAssignment();
      if (!selectedAsset) return;

      // Check if assignment is allowed
      if (!this.canAssignUser(selectedAsset)) {
        this.userAssignmentError.set('Cannot assign user. Asset status must be "In Stock"');
        return;
      }

      const formData = this.userAssignmentForm.value;
      const assignmentRequest: AssetUserAssignmentDTO = {
        assetId: selectedAsset.assetId!,
        userId: formData.userId,
        remarks: formData.remarks || undefined
      };

      this.userAssignmentLoading.set(true);

      this.assignmentService.assignUser(assignmentRequest)
        .pipe(
          takeUntil(this.destroy$),
          finalize(() => this.userAssignmentLoading.set(false))
        )
        .subscribe({
          next: (response) => {
            // After successful assignment, change status to "active"
            this.onStatusChange(selectedAsset, 'ACTIVE', `User assigned: ${this.getUserName(formData.userId)}`);
            this.showSuccess(`User assigned successfully to ${selectedAsset.name} and status changed to Active`);
            this.closeUserAssignmentModal();
            this.loadAssets(); // Refresh to show the assignment and status change
          },
          error: (error) => {
            console.error('Error assigning user:', error);
            this.userAssignmentError.set('Failed to assign user to asset');
            
            // Enhanced error handling
            if (error.status === 400) {
              this.userAssignmentError.set('Invalid assignment data. Please check your selection.');
            } else if (error.status === 404) {
              this.userAssignmentError.set('Asset or user not found.');
            } else if (error.status === 409) {
              this.userAssignmentError.set('Asset is already assigned to another user.');
            } else {
              this.userAssignmentError.set('Failed to assign user. Please try again.');
            }
          }
        });
    } else {
      this.markFormGroupTouched(this.userAssignmentForm);
    }
  }

  /**
   * Unassign user from asset
   */
  onUnassignUser(): void {
          // Comma-separated format
          return asset.tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
        }
      }
      return [];
    } catch (error) {
      console.error('Error parsing asset tags:', error);
      return [];
    }
  }

  // ✅ NEW: Inline "Add Tag" Methods

  /**
   * Show inline add tag input
   */
  showAddTagInput(): void {
    this.showAddTagInline.set(true);
    this.newTagName.set('');
    this.addTagError.set(null);
  }

  /**
   * Hide inline add tag input
   */
  hideAddTagInput(): void {
    this.showAddTagInline.set(false);
    this.newTagName.set('');
    this.addTagError.set(null);
  }

  /**
   * Add and assign new tag by name
   */
  onAddAndAssignTag(): void {
    const asset = this.selectedAssetForTagAssignment();
    const tagName = this.newTagName().trim();
    
    if (!asset) {
      this.addTagError.set('No asset selected');
      return;
    }

    if (!tagName || tagName.length === 0) {
      this.addTagError.set('Please enter a tag name');
      return;
    }

    if (tagName.length < 2) {
      this.addTagError.set('Tag name must be at least 2 characters');
      return;
    }

    if (tagName.length > 50) {
      this.addTagError.set('Tag name must be less than 50 characters');
      return;
    }

    console.log('🔗 Adding and assigning new tag:', { assetId: asset.assetId, tagName });
    this.addTagLoading.set(true);
    this.addTagError.set(null);

    const assignment: AssetTagAssignmentByNameDTO = {
      assetId: asset.assetId!,
      tagName: tagName,
      remarks: `Created and assigned from UI on ${new Date().toLocaleDateString()}`
    };

    this.assignmentService.assignTagToAssetByName(assignment)
      .pipe(
        takeUntil(this.destroy$),
        finalize(() => this.addTagLoading.set(false))
      )
      .subscribe({
        next: (response) => {
          console.log('✅ Tag created and assigned successfully:', response);
          this.showSuccess(response.message || 'Tag created and assigned successfully');
          
          // Hide the inline input
          this.hideAddTagInput();
          
          // Refresh tag assignments to show the new tag
          this.loadAssetTagAssignments(asset.assetId!);
          
          // Refresh available tags list
          this.loadInitialAssignmentData();
          
          // Refresh assets to show updated tags in the main list
          this.refreshAssetsData();
        },
        error: (error) => {
          console.error('❌ Error creating and assigning tag:', error);
          console.error('❌ Error details:', {
            status: error.status,
            statusText: error.statusText,
            message: error.message,
            error: error.error
          });
          
          // Show user-friendly error message
          let errorMessage = 'Failed to create and assign tag';
          if (error.status === 400) {
            errorMessage = 'Invalid tag name or tag already exists. Please try a different name.';
          } else if (error.status === 404) {
            errorMessage = 'Asset not found. Please refresh and try again.';
          } else if (error.status === 409) {
            errorMessage = 'Tag with this name already exists and is assigned to this asset.';
          } else if (error.status === 500) {
            errorMessage = 'Server error. Please try again later.';
          } else if (error.message) {
            errorMessage = error.message;
          }
          
          this.addTagError.set(errorMessage);
          this.showError(errorMessage);
        }
      });
  }

  /**
   * Handle Enter key press in tag name input
   */
  onTagNameKeyPress(event: KeyboardEvent): void {
    if (event.key === 'Enter') {
      event.preventDefault();
      this.onAddAndAssignTag();
    } else if (event.key === 'Escape') {
      event.preventDefault();
      this.hideAddTagInput();
    }
  }

  /**
   * ✅ NEW: Validate and debug filter configuration
   * This method helps debug filter dropdown options and form values
   */
  debugFilterConfiguration(): void {
    console.log('🔍 === FILTER CONFIGURATION DEBUG ===');
    
    // Check dropdown options
    console.log('📋 Status Filter Options:', this.statusFilterDropdownOptions());
    console.log('📋 Owner Type Filter Options:', this.ownerTypeFilterOptions());
    console.log('📋 Asset Types:', this.assetTypes().map(t => ({ id: t.id, name: t.name })));
    console.log('📋 Vendors:', this.vendors().map(v => ({ id: v.id, name: v.name })));
    
    // Check current form values
    console.log('📝 Current Form Values:', this.filterForm.value);
    console.log('📝 Current Filters Signal:', this.currentFilters());
    
    // Check configuration service values
    console.log('⚙️ Configuration Service Status Options:', this.configService.getAssetStatusesForFilter());
    console.log('⚙️ Configuration Service Owner Options:', this.configService.getOwnerTypesForFilter());
    
    console.log('🔍 === END FILTER DEBUG ===');
  }

  /**
   * ✅ NEW: Test filter functionality
   * This method can be called to test various filter combinations
   */
  testFilterFunctionality(): void {
    console.log('🧪 === COMPREHENSIVE FILTER TEST ===');
    
    // Test current form state
    console.log('📝 Current form values:', this.filterForm.value);
    console.log('📝 Current filters signal:', this.currentFilters());
    
    // Test vendor data
    console.log('🏢 Vendor data analysis:');
    const vendors = this.vendors();
    console.log('  - Total vendors loaded:', vendors.length);
    console.log('  - Vendor details:', vendors.map(v => ({ id: v.id, name: v.name, idType: typeof v.id })));
    
    // Test asset data
    console.log('📦 Asset data analysis:');
    const assets = this.assets();
    console.log('  - Total assets loaded:', assets.length);
    
    // Group assets by vendor ID
    const assetsByVendor = assets.reduce((acc, asset) => {
      const vendorId = asset.vendorId || 'null';
      if (!acc[vendorId]) acc[vendorId] = [];
      acc[vendorId].push({ id: asset.assetId, name: asset.name });
      return acc;
    }, {} as any);
    
    console.log('  - Assets grouped by vendor ID:', assetsByVendor);
    console.log('  - Vendor IDs in assets:', Object.keys(assetsByVendor));
    
    // Test specific vendor ID 4
    const vendor4Assets = assets.filter(a => a.vendorId === 4);
    console.log('🔍 Assets with vendor ID 4 (number or string):', vendor4Assets.length);
    if (vendor4Assets.length > 0) {
      console.log('  - Vendor 4 assets:', vendor4Assets.map(a => ({ 
        id: a.assetId, 
        name: a.name, 
        vendorId: a.vendorId, 
        vendorIdType: typeof a.vendorId 
      })));
    }
    
    // Test filter mapping
    console.log('🔄 Testing filter mapping:');
    const testFormValue = { vendor: '4' };
    const mappedFilter = {
      vendorId: testFormValue.vendor || undefined
    };
    console.log('  - Test form value:', testFormValue);
    console.log('  - Mapped filter:', mappedFilter);
    
    // Test backend parameter
    console.log('🌐 Backend parameter test:');
    console.log('  - Would send to backend: vendorId=4');
    console.log('  - Parameter type: string');
    
    console.log('✅ Filter test completed - check console for details');
  }

  /**
   * ✅ NEW: Test vendor filtering specifically
   */
  testVendorFiltering(vendorId: string): void {
    console.log(`🧪 Testing vendor filtering for ID: ${vendorId}`);
    
    // Manually set the filter
    this.filterForm.patchValue({ vendor: vendorId });
    
    // Log what should happen
    console.log('📋 Expected behavior:');
    console.log(`  - Form vendor field: ${vendorId}`);
    console.log(`  - Should map to: vendorId=${vendorId}`);
    console.log(`  - Should send to backend: ?vendorId=${vendorId}`);
    
    // Check if assets exist with this vendor
    const vendorIdNum = Number(vendorId);
    const matchingAssets = this.assets().filter(a => 
      a.vendorId === vendorIdNum
    );
    console.log(`  - Assets with vendor ID ${vendorId}:`, matchingAssets.length);
    
    if (matchingAssets.length === 0) {
      console.warn(`⚠️ No assets found with vendor ID ${vendorId}`);
      console.log('💡 This might be why filtering appears not to work');
    }
  }

  // ✅ NEW: Methods for collapsible sections
  toggleEditableSection(asset: Asset): void {
    if (!asset.assetId) return;
    const currentMap = this.editableSections();
    const newMap = new Map(currentMap);
    const isOpen = newMap.get(asset.assetId) || false;
    newMap.set(asset.assetId, !isOpen);
    this.editableSections.set(newMap);
  }

  isEditableSectionOpen(asset: Asset): boolean {
    if (!asset.assetId) return false;
    return this.editableSections().get(asset.assetId) || false;
  }

  togglePOSection(asset: Asset): void {
    if (!asset.assetId) return;
    const currentMap = this.poSections();
    const newMap = new Map(currentMap);
    const isOpen = newMap.get(asset.assetId) || false;
    newMap.set(asset.assetId, !isOpen);
    this.poSections.set(newMap);
  }

  isPOSectionOpen(asset: Asset): boolean {
    if (!asset.assetId) return false;
    return this.poSections().get(asset.assetId) || false;
  }

  // ✅ NEW: Download asset details functionality
  downloadAssetDetails(asset: Asset): void {
    // Create comprehensive asset details object
    const assetDetails = {
      'Asset Information': {
        'Name': asset.name,
        'Serial Number': asset.serialNumber,
        'IT Asset Code': asset.itAssetCode || 'N/A',
        'Status': this.getStatusDisplayName(asset.status),
        'Model': this.getModelName(asset.modelId),
        'Make': this.getMakeName(asset.makeId),
        'Asset Type': this.getAssetTypeName(asset.typeId),
        'OS': this.getOSName(asset.osId),
        'OS Version': this.getOSVersionName(asset.osVersionId)
      },
      'Network Information': {
        'MAC Address': asset.macAddress || 'N/A',
        'IPv4 Address': asset.ipv4Address || 'N/A',
        'Inventory Location': asset.inventoryLocation || 'N/A'
      },
      'Assignment Details': {
        'Assigned User': asset.currentUserId ? this.getUserName(asset.currentUserId) : 'Unassigned',
        'Assignment Date': asset.currentUserId ? new Date().toLocaleDateString() : 'N/A'
      },
      'Purchase Information': {
        'PO Number': asset.poNumber || 'N/A',
        'Invoice Number': asset.invoiceNumber || 'N/A',
        'Vendor': this.getname(asset.vendorId),
        'Acquisition Date': asset.acquisitionDate ? new Date(asset.acquisitionDate).toLocaleDateString() : 'N/A',
        'Acquisition Price': asset.acquisitionPrice ? `₹${asset.acquisitionPrice.toLocaleString('en-IN')}` : 'N/A',
        'Rental Amount': asset.rentalAmount ? `₹${asset.rentalAmount.toLocaleString('en-IN')}` : 'N/A',
        'Owner Type': asset.ownerType || 'N/A',
        'Acquisition Type': asset.acquisitionType || 'N/A'
      },
      'Financial Details': {
        'Current Price': asset.currentPrice ? `₹${asset.currentPrice.toLocaleString('en-IN')}` : 'N/A',
        'Depreciation %': asset.depreciationPct ? `${asset.depreciationPct}%` : 'N/A',
        'Min Contract Period': asset.minContractPeriod || 'N/A',
        'Lease End Date': asset.leaseEndDate ? new Date(asset.leaseEndDate).toLocaleDateString() : 'N/A'
      },
      'Warranty Information': {
        'Warranty Expiry': asset.warrantyExpiry ? new Date(asset.warrantyExpiry).toLocaleDateString() : 'N/A'
      }
    };

    // Generate CSV content
    const csvContent = this.generateCSV(assetDetails, asset);
    
    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    if (link.download !== undefined) {
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `asset_${asset.name.replace(/[^a-z0-9]/gi, '_')}_${asset.serialNumber}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    this.showSuccess(`Asset details for ${asset.name} downloaded successfully`);
  }

  private generateCSV(assetDetails: any, asset: Asset): string {
    let csvContent = `Asset Details Report\n`;
    csvContent += `Generated: ${new Date().toLocaleString()}\n`;
    csvContent += `Asset: ${asset.name} (${asset.serialNumber})\n\n`;

    Object.keys(assetDetails).forEach(section => {
      csvContent += `${section}\n`;
      csvContent += `${'='.repeat(section.length)}\n`;
      
      Object.entries(assetDetails[section]).forEach(([key, value]) => {
        csvContent += `${key},${value}\n`;
      });
      
      csvContent += `\n`;
    });

    return csvContent;
  }

  // ✅ NEW: Assignment history modal
  openAssignmentHistoryModal(asset: Asset): void {
    this.selectedAssetForAssignmentHistory.set(asset);
    this.loadAssignmentHistory(asset.assetId!);
    this.showAssignmentHistoryModal.set(true);
  }

  // ✅ NEW: Check if user can be assigned (only when status is instock)
  canAssignUser(asset: Asset): boolean {
    return asset.status.toLowerCase() === 'instock' || asset.status.toLowerCase() === 'in stock';
  }

  // ✅ NEW: Show PO Details modal
  showPODetails(poNumber: string): void {
    this.selectedPOForDetails.set(poNumber);
    this.loadPODetailsForModal(poNumber);
    this.showPODetailsModal.set(true);
  }

  // ✅ NEW: Load PO details for the info modal
  private loadPODetailsForModal(poNumber: string): void {
    this.poDetailsLoading.set(true);
    // Find PO details from existing purchase orders
    const po = this.purchaseOrders().find(p => p.poNumber === poNumber);
    if (po) {
      // Use actual PO data instead of hardcoded values
      const details: PODetails = {
        poNumber: po.poNumber,
        acquisitionType: po.acquisitionType || 'BOUGHT',
        acquisitionDate: po.acquisitionDate || new Date().toISOString().split('T')[0],
        invoiceNumber: po.invoiceNumber || `INV-${po.poNumber}`,
        acquisitionPrice: po.acquisitionPrice || 0,
        vendorId: po.vendorId || 1,
        ownerType: po.ownerType || 'CELCOM',
        leaseEndDate: po.leaseEndDate || '',
        minContractPeriod: po.minContractPeriod || 12,
        rentalAmount: po.rentalAmount || 0,
        currentPrice: po.currentPrice || po.acquisitionPrice || 0,
        totalDevices: po.totalDevices || 1
      };
      this.selectedPODetails.set(details);
    } else {
      this.showError('PO details not found');
    }
    this.poDetailsLoading.set(false);
  }

  // ✅ NEW: Load assignment history
  private loadAssignmentHistory(assetId: number): void {
    this.assignmentHistoryLoading.set(true);
    // Mock assignment history for now
    setTimeout(() => {
      const mockHistory: AssetUserAssignment[] = [
        {
          id: 1,
          assetId: assetId,
          userId: 1,
          userName: 'John Doe',
          assignedDate: new Date().toISOString(),
          remarks: 'Initial assignment'
        }
      ];
      this.assignmentHistory.set(mockHistory);
      this.assignmentHistoryLoading.set(false);
    }, 500);
  }

  // ✅ NEW: PO Number change with confirmation
  onPONumberChange(asset: Asset, newPONumber: string): void {
    if (newPONumber === (asset.poNumber || '')) {
      return; // No change
    }

    const message = newPONumber 
      ? `Are you sure you want to change PO Number from "${asset.poNumber || 'None'}" to "${newPONumber}"?`
      : `Are you sure you want to remove the PO Number "${asset.poNumber}"?`;

    if (confirm(message)) {
      // Create updated asset object
      const updatedAsset: Asset = {
        ...asset,
        poNumber: newPONumber || undefined
      };

      // Call the asset service to update
      this.assetService.updateAsset(updatedAsset.assetId!, updatedAsset).pipe(
        takeUntil(this.destroy$)
      ).subscribe({
        next: (response) => {
          this.showSuccess(`PO Number updated successfully`);
          this.loadAssets(); // Refresh the assets list
        },
        error: (error) => {
          console.error('Error updating PO Number:', error);
          this.showError('Failed to update PO Number. Please try again.');
          // Revert the dropdown selection
          this.loadAssets();
        }
      });
    } else {
      // User cancelled - revert the dropdown
      // Force refresh to reset the dropdown value
      this.triggerChangeDetection();
    }
  }
} 
